# 아키텍처 결정 기록 (Architecture Decision Records)

프로젝트의 주요 설계 결정과 그 사유를 기록합니다.
새로운 결정이나 기존 결정 변경 시 이 문서에 추가합니다.

---

## 목차

| # | 결정 | 상태 | 날짜 |
|---|------|------|------|
| [001](#adr-001) | Vanilla JavaScript 사용 | 유지 | 2026-02-11 |
| [002](#adr-002) | Fisher-Yates 셔플 알고리즘 | 유지 | 2026-02-11 |
| [003](#adr-003) | HTML/CSS/JS 파일 분리 | 유지 | 2026-02-11 |
| [004](#adr-004) | LocalStorage 이력 저장 | 유지 | 2026-02-11 |
| [005](#adr-005) | 이력 최대 20개 제한 | 유지 | 2026-02-11 |
| [006](#adr-006) | 동시 추첨 최대 5세트 | 유지 | 2026-02-11 |
| [007](#adr-007) | UUID v4 이력 식별자 | 유지 | 2026-02-11 |
| [008](#adr-008) | Clipboard API 사용 | 유지 | 2026-02-11 |
| [009](#adr-009) | textContent 사용 (innerHTML 금지) | 유지 | 2026-02-11 |
| [010](#adr-010) | CLAUDE.md 세션 가이드 운용 | 유지 | 2026-02-11 |
| [011](#adr-011) | 문서 중복 제거 리팩토링 | 적용 완료 | 2026-02-11 |
| [012](#adr-012) | phase4-plan → phase4-architecture 이름 변경 | 적용 완료 | 2026-02-11 |
| [013](#adr-013) | 번호 제외 UI: 토글 버튼 그리드 | 유지 | 2026-02-11 |

---

## ADR-001: Vanilla JavaScript 사용

**날짜**: 2026-02-11 (프로젝트 시작)
**상태**: 유지
**관련 커밋**: `f64fd93`

### 맥락
웹 기반 로또번호 추첨기를 개발하면서 프론트엔드 기술을 선택해야 했다.

### 결정
React, Vue 등 프레임워크 없이 순수 JavaScript(ES6+)만 사용한다.

### 사유
- **단순한 기능 범위**: 버튼 클릭 → 번호 생성 → 표시. 프레임워크가 해결해주는 상태 관리, 라우팅, 컴포넌트 트리 등이 불필요
- **빌드 도구 불필요**: npm, webpack 등의 설정 없이 `index.html`을 바로 열어 실행 가능
- **학습 목적**: 웹 기본 기술(DOM API, 이벤트, LocalStorage)을 직접 다루는 경험
- **배포 간소화**: GitHub Pages에 정적 파일만 올리면 완료

### 검토한 대안
- **React**: 컴포넌트 기반 UI에 유리하나, 이 규모에서는 오버엔지니어링
- **Vue**: 진입 장벽이 낮지만, 여전히 빌드 설정이 필요
- **jQuery**: 레거시. 모던 브라우저에서는 Vanilla JS로 충분

### 재검토 조건
Phase 4(백엔드 연동)에서 UI 복잡도가 크게 증가할 경우 프레임워크 도입 재검토.

---

## ADR-002: Fisher-Yates 셔플 알고리즘

**날짜**: 2026-02-11 (Phase 2)
**상태**: 유지
**관련 커밋**: `f64fd93`
**코드**: `js/app.js` - `generateSingleSet()`

### 맥락
1~45에서 중복 없이 6개를 뽑는 알고리즘을 선택해야 했다.

### 결정
Fisher-Yates (Knuth) 셔플로 배열 전체를 섞은 뒤 앞 6개를 취한다.

### 사유
- **균등 분포 보장**: 모든 순열이 동일한 확률로 생성됨 (수학적으로 증명됨)
- **O(n) 시간, O(1) 공간**: 추가 메모리 없이 in-place 셔플
- **구현 단순**: 5줄 이내로 구현 가능
- **1000회 테스트 통과**: 분포 균등성 검증 완료 (커밋 `8c2bb91`)

### 검토한 대안
- **Set + while 루프**: `Set`에 랜덤 숫자를 넣고 6개 될 때까지 반복. 간단하지만 최악의 경우 무한 루프에 가까워질 수 있고, 균등성 증명이 불직관적
- **Array.sort(() => Math.random() - 0.5)**: 브라우저 sort 구현에 따라 편향 발생 가능. 균등 분포를 보장하지 않음
- **crypto.getRandomValues()**: 암호학적 안전성이 필요하지 않은 오락용이므로 `Math.random()`으로 충분

---

## ADR-003: HTML/CSS/JS 파일 분리

**날짜**: 2026-02-11
**상태**: 유지
**관련 커밋**: `9f75d88`

### 맥락
초기에는 `index.html` 단일 파일(152줄)에 HTML, CSS, JS가 모두 포함되어 있었다.

### 결정
`index.html`, `css/style.css`, `js/app.js` 3개 파일로 분리한다.

### 사유
- **관심사 분리(SoC)**: 구조(HTML), 표현(CSS), 동작(JS)을 독립적으로 수정 가능
- **캐싱**: CSS/JS 파일이 별도로 캐시되어 재방문 시 로딩 속도 향상
- **가독성**: 152줄 단일 파일 → 각각 21줄/131줄/42줄로 역할이 명확
- **협업 충돌 최소화**: 스타일 변경과 로직 변경이 다른 파일에서 이루어짐

### 검토한 대안
- **단일 파일 유지**: 소규모 프로젝트에서 간편하나, Phase 3 기능 추가로 파일이 급격히 커질 것으로 예상
- **모듈 시스템(ES Modules)**: `import/export` 사용 가능하나, 파일 프로토콜(`file://`)에서 CORS 제한 발생. 로컬 서버 필요

---

## ADR-004: LocalStorage 이력 저장

**날짜**: 2026-02-11 (Phase 3, Step 1)
**상태**: 유지
**관련 커밋**: `5500aba`
**명세**: `docs/spec.md` F-003

### 맥락
추첨 이력을 저장하여 사용자가 과거 결과를 조회할 수 있어야 했다.

### 결정
브라우저 LocalStorage에 JSON 형태로 저장한다. key는 `lotto_history`.

### 사유
- **서버 불필요**: Phase 3까지는 백엔드 없이 클라이언트만으로 동작
- **영속성**: SessionStorage와 달리 브라우저를 닫아도 유지됨
- **간단한 API**: `getItem`/`setItem` 두 메서드로 충분
- **용량 충분**: 20개 이력 기준 < 50KB (LocalStorage 한도 5MB)

### 검토한 대안
- **SessionStorage**: 브라우저 닫으면 삭제됨. 이력 보존 목적에 부적합
- **IndexedDB**: 비동기 API, 트랜잭션 기반. 이 규모에서는 과도한 복잡성
- **Cookie**: 4KB 제한, 매 요청에 서버로 전송됨. 부적합
- **서버 DB**: Phase 4에서 도입 예정. 현재는 불필요

### 재검토 조건
Phase 4에서 사용자 인증 + 서버 DB 도입 시, LocalStorage는 오프라인 캐시 역할로 전환 예정.

---

## ADR-005: 이력 최대 20개 제한

**날짜**: 2026-02-11 (Phase 3, Step 1)
**상태**: 유지
**관련 커밋**: `5500aba`
**코드**: `js/app.js` - `MAX_HISTORY = 20`

### 맥락
LocalStorage에 이력을 무제한 저장하면 용량 문제와 UI 성능 저하가 발생할 수 있었다.

### 결정
최대 20개까지 저장하고, 초과 시 가장 오래된 항목부터 삭제한다 (FIFO).

### 사유
- **UI 가독성**: 20개 이상은 스크롤이 길어져 사용성 저하
- **LocalStorage 용량 보호**: 무제한 축적 방지
- **성능**: DOM 렌더링 부담 최소화
- **충분한 분량**: 일반 사용자가 최근 이력을 확인하기에 20개면 적절

### 검토한 대안
- **10개**: 너무 적어 자주 사용하는 사용자에게 불편
- **50개**: UI 스크롤이 과도해지고, 오래된 이력의 활용도가 낮음
- **무제한 + 페이지네이션**: 구현 복잡도 증가. 이 규모에서 불필요

---

## ADR-006: 동시 추첨 최대 5세트

**날짜**: 2026-02-11 (Phase 3, Step 2)
**상태**: 유지
**관련 커밋**: `2d014ca`
**명세**: `docs/spec.md` F-004

### 맥락
한 번에 여러 세트를 추첨하는 기능에서 최대 세트 수를 정해야 했다.

### 결정
1~5세트 선택 가능. 드롭다운(`<select>`)으로 제공.

### 사유
- **실제 로또 구매 기준**: 한국 로또 1회 구매 시 최대 5게임 (실제 규칙 반영)
- **UI 레이아웃**: 그리드 2열 배치 시 5개까지가 화면에 적절히 들어감
- **이력 부담**: 5세트 × 20회 = 최대 100개 이력 항목. MAX_HISTORY(20)로 자연스럽게 제어
- **모바일 UX**: 5개 세로 배치 시에도 스크롤이 과도하지 않음

### 검토한 대안
- **10세트**: 화면이 지나치게 길어지고, 실제 로또 규칙과 괴리
- **자유 입력**: 검증 로직 복잡화, 비정상 값 입력 위험

---

## ADR-007: UUID v4 이력 식별자

**날짜**: 2026-02-11 (Phase 3, Step 1)
**상태**: 유지
**관련 커밋**: `5500aba`
**코드**: `js/app.js` - `generateUUID()`

### 맥락
이력 항목마다 고유 식별자가 필요했다. 서버 없이 클라이언트에서 생성해야 했다.

### 결정
UUID v4를 클라이언트에서 자체 생성한다 (`Math.random()` 기반).

### 사유
- **서버 불필요**: 순번(auto-increment)은 서버 DB가 필요하지만, UUID는 클라이언트에서 독립 생성 가능
- **충돌 확률 극히 낮음**: v4 UUID는 122비트 랜덤. 20개 이력에서 충돌 확률 ≈ 0
- **Phase 4 대비**: 서버 DB 마이그레이션 시 ID 충돌 없이 병합 가능
- **표준 형식**: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx` 형태로 디버깅 용이

### 검토한 대안
- **타임스탬프**: 밀리초 단위에서도 동시 추첨(여러 세트) 시 충돌 가능
- **순번 카운터**: LocalStorage에 카운터를 별도 관리해야 하고, 초기화 시 충돌
- **crypto.randomUUID()**: 브라우저 지원 범위가 Math.random 기반보다 좁음 (Safari 15.4+)

---

## ADR-008: Clipboard API 사용

**날짜**: 2026-02-11 (Phase 3, Step 3)
**상태**: 유지
**관련 커밋**: `60d762c`
**코드**: `js/app.js` - `copyToClipboard()`

### 맥락
추첨 결과를 클립보드에 복사하는 기능이 필요했다.

### 결정
`navigator.clipboard.writeText()` (Clipboard API)를 사용한다.

### 사유
- **모던 표준**: W3C 표준 API. 비동기(Promise) 기반으로 결과 확인 가능
- **보안 모델**: 사용자 제스처(클릭) 필요 → 악의적 복사 방지
- **에러 처리**: try-catch로 실패 시 토스트 피드백 가능
- **대상 브라우저 전부 지원**: Chrome 66+, Firefox 63+, Safari 13.1+

### 검토한 대안
- **document.execCommand('copy')**: 2020년부터 deprecated. 동기식이라 에러 처리 어려움
- **textarea 임시 생성 후 select + copy**: execCommand 기반 우회법. 해키하고 모바일에서 불안정

### 제약사항
HTTPS 또는 localhost에서만 작동. HTTP에서는 에러 토스트로 안내.

---

## ADR-009: textContent 사용 (innerHTML 금지)

**날짜**: 2026-02-11 (프로젝트 시작)
**상태**: 유지

### 맥락
DOM에 숫자나 텍스트를 렌더링할 때 XSS 방지 방법을 정해야 했다.

### 결정
모든 텍스트 삽입에 `textContent`를 사용하고, `innerHTML` 사용을 금지한다.
단, 컨테이너 초기화(`container.innerHTML = ''`)는 예외적으로 허용.

### 사유
- **XSS 방지**: 현재는 사용자 입력이 없지만, Phase 3(번호 제외)부터 사용자 입력 처리 예정. 습관적 보안 코딩
- **OWASP 권장**: 텍스트 삽입 시 `textContent` 사용이 웹 보안 모범 사례
- **성능**: `innerHTML`은 HTML 파싱이 발생하지만, `textContent`는 단순 텍스트 설정으로 더 빠름

---

## ADR-010: CLAUDE.md 세션 가이드 운용

**날짜**: 2026-02-11
**상태**: 유지
**관련 커밋**: `53202e1`

### 맥락
Claude Code는 세션이 끊기면 이전 작업 맥락을 잃는다. 새 세션에서 프로젝트를 즉시 이해하고 작업을 이어갈 방법이 필요했다.

### 결정
`CLAUDE.md`를 프로젝트 루트에 두고, 세션 시작에 필요한 최소한의 핵심 정보만 담는다. 상세 정보는 `docs/` 문서로 위임.

### 사유
- **자동 로드**: Claude Code는 `CLAUDE.md`를 매 세션 시스템 프롬프트에 자동 로드
- **토큰 비용**: 매번 로드되므로 분량 최소화 필요 (ADR-011 참조)
- **빠른 시작**: "Step 4 시작해줘" 한 마디로 즉시 작업 가능
- **역할 분리**: CLAUDE.md = 세션 가이드 / docs/ = 상세 참조 문서

### 변경 이력
- 초기: ~380줄 (모든 정보를 포함)
- 2026-02-11 리팩토링 후: ~130줄 (ADR-011 적용)

---

## ADR-011: 문서 중복 제거 리팩토링

**날짜**: 2026-02-11
**상태**: 적용 완료

### 맥락
프로젝트 문서 7개 파일에서 14개 중복 항목이 발견되었다. 특히 CLAUDE.md(~380줄)는 매 세션 로드되어 토큰 낭비가 심했다. 동일한 데이터 구조가 3곳에, 테스트 시나리오가 3곳에 반복되어 있었다.

### 결정
"단일 진실 소스(Single Source of Truth)" 원칙을 적용. 각 문서에 명확한 역할을 부여하고, 중복 내용은 원본 참조로 대체.

| 문서 | 역할 (원본 담당 영역) |
|------|----------------------|
| `docs/spec.md` | 기능 명세, API, 데이터 구조 |
| `docs/plan.md` | 진행 상황, 액션 아이템 |
| `docs/design.md` | 디자인 시스템, CSS |
| `docs/tech.md` | 기술 스택, 아키텍처, 성능 |
| `test/README.md` | 테스트 항목, 커버리지 |
| `CLAUDE.md` | 세션 가이드 (요약 + 참조) |

### 사유
- **토큰 절감**: CLAUDE.md 445줄 → 130줄 (71% 감소). 매 세션 ~300줄 절약
- **유지보수성**: 정보 수정 시 1곳만 변경하면 됨
- **정합성**: 중복 문서 간 내용 불일치(오래된 줄 수, Phase 라벨 등) 방지

### 결과
전체 문서 1,898줄 → 1,163줄 (39% 감소)

---

## ADR-012: phase4-plan → phase4-architecture 이름 변경

**날짜**: 2026-02-11
**상태**: 적용 완료
**관련 커밋**: `4c1e7b1`

### 맥락
`docs/phase4-plan.md`와 `docs/plan.md`가 이름만 보면 둘 다 "계획" 문서로 보였다. 실제로는 역할이 완전히 다른데, 이름이 그 차이를 드러내지 못했다.

- `plan.md` (181줄): 전체 Phase의 **진행 관리** — 체크리스트, 진행률, 액션 아이템
- `phase4-plan.md` (735줄): Phase 4의 **기술 설계** — 아키텍처 3가지 옵션, DB 스키마, API 엔드포인트 15개, 비용 예측

### 결정
`phase4-plan.md` → `phase4-architecture.md`로 이름을 변경한다.

### 사유
- **역할 구분**: 문서 분리 기준은 Phase 번호가 아니라 문서 역할이어야 한다. plan = 진행 관리, architecture = 기술 설계
- **혼동 방지**: "plan이 2개?" 라는 의문 제거
- **확장성**: 향후 Phase 5 등이 추가되어도 `plan.md`는 진행 관리 단일 문서로 유지하고, 대규모 설계가 필요한 Phase만 별도 architecture 문서를 만들면 됨

### 검토한 대안
- **phase4-design.md**: "design"이 이미 `design.md`(UI/CSS 디자인)와 겹쳐 혼동 가능
- **phase4-spec.md**: "spec"이 이미 `spec.md`(기능 명세)와 겹쳐 혼동 가능
- **각 Phase별 plan 분리**: Phase 1~3은 이미 완료된 소규모 작업이라 개별 파일로 분리하면 아무도 안 보는 작은 파일만 생김

---

## ADR-013: 번호 제외 UI: 토글 버튼 그리드

**날짜**: 2026-02-11 (Phase 3, Step 4)
**상태**: 유지
**명세**: `docs/spec.md` F-005

### 맥락
F-005 수동 번호 제외 기능에서 사용자가 제외할 번호를 선택하는 UI 방식을 정해야 했다.

### 결정
1~45 숫자를 9열 그리드의 토글 버튼으로 표시한다. 클릭하면 제외/해제가 토글된다.

### 사유
- **직관성**: 숫자를 보면서 바로 클릭. 입력값 검증이 불필요
- **터치 친화적**: 모바일에서 버튼 탭이 텍스트 입력보다 편리
- **시각적 피드백**: 제외된 번호가 즉시 회색 + 취소선으로 표시
- **기존 UI와 일관성**: 이력 섹션과 동일한 접이식(토글) 패턴 재사용

### 검토한 대안
- **체크박스 목록**: 45개 체크박스를 나열. 공간을 많이 차지하고 시각적 매력이 낮음
- **텍스트 입력**: 콤마로 구분된 숫자 직접 입력. 컴팩트하지만 입력 검증이 복잡하고 오타 위험
